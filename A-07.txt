1. 동적할당배열을 이용한 (circular queue) ]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MALLOC(p,s)\
	if(!((p) = malloc(s))){\
		fprintf(stderr, "Insufficient memory");\
		exit(EXIT_FAILURE);\
	}

#define MAX_NAME_SIZE 10
#define MAX_QUEUE_SIZE 3

typedef struct { 
	int id;
	char name[MAX_NAME_SIZE];
} element;
element *queue;

int capacity = 2; 
int rear = 0;
int front = 0;
int count =0;

element queueEmpty() 
{
	fprintf(stderr, "queue is empty, cannot delete element.\n");
	element err;
	err.id = -1;
	exit(EXIT_FAILURE);
	return err;
}


element deleteq()
{
	element item;
	if(front == rear)
		return queueEmpty();
		
	front = (front + 1) % MAX_QUEUE_SIZE;
	return queue[front];
}

void copy(element* a, element* b, element* c)
{
	while (a != b)
		*c++ = *a++;
}

void queueFull() {
	int start;
	element* newQueue;
	MALLOC(newQueue, 2 * capacity * sizeof(*queue));

	start = (front + 1) % capacity;
	if (start < 2)
		copy(queue + start, queue + start + capacity - 1, newQueue);
	else {
		copy(queue + start, queue + capacity, newQueue);
		copy(queue, queue + rear + 1, newQueue + capacity - start);
	}

	front = 2 * capacity - 1;
	rear = capacity - 2;
	capacity *= 2;
	free(queue);
	queue = newQueue;
    
	printf("queue capacity is doubled.\n");
	printf("current queue capacity is %d.\n", capacity);
}

void addq(element item)
{
	rear = (rear + 1) % capacity;
	if(front == rear)
		queueFull();

	queue[rear] = item;
}


void qprint()
{
	int i;
	for (i = 0 + count; i <= rear; i++)
		printf("%d,  %s\n", queue[i].id, queue[i].name);
	printf("\n");
}
int main(void)
{
	printf("add 1 Jung\n");
	printf("delete\n");
	printf("printq\n\n");
	printf("**************************************************\n");

	element student;
	char input[100];
	char *op = NULL;
	char *delimiter = " ";

	queue = (element*)malloc(sizeof(element) *(MAX_QUEUE_SIZE + 1));

	while(1)
	{
		gets(input);
		op = strtok(input, delimiter);

		if(!strcmp(op, "add"))
		{	
			sscanf(input + strlen(op) + 1, "%d %s", &student.id, student.name); // 숫자 입력되기전 자름
			addq(student);
		}else if(!strcmp(op, "qprint"))
		{
			qprint();
		}
		else if(!strcmp(op, "delete"))
		{	
			element item = deleteq();
			count++;
		}else printf("Wrong command! try again!\n");
			
	}
}


//matrix 1차원 정적을 통해 만들기
#include <stdio.h>

typedef struct{
    int row;
    int col;
    int value;
}term;

int main(void)
{
    term mat[8] = {
        {20, 20, 7},
        {0, 17, 5},
        {4, 11, 1},
        {7, 12, 30},
        {9, 7, 42},
        {11, 8, 84},
        {11, 17, 73},
        {18, 13, 87},
    };

    int i, j;
    int cur = 1;

    for(i = 0; i < mat[0].row; i++){
        for(j = 0; j < mat[0].col; j++){
            if(mat[cur].row == i && mat[cur].col == j){
                printf("%3d", mat[cur++].value);
			}
            else
                printf("%3d" , 0);
        }
		printf("\n");
    }

}

//gangdaechan@gangdaechan-ui-MacBookPro test % cc main.c -o main
//gangdaechan@gangdaechan-ui-MacBookPro test % ./main
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  5  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0 30  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0 42  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0 84  0  0  0  0  0  0  0  0 73  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0 87  0  0  0  0  0  0
 // 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0